/* Copyright (C) 2005-2021 Joël Krähemann
 * Permission is granted to copy, distribute and/or modify this document
 * under the terms of the GNU Free Documentation License, Version 1.3
 * or any later version published by the Free Software Foundation;
 * with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
 * A copy of the license is included in the section entitled "GNU
 * Free Documentation License".
 */

#include <glib.h>
#include <glib-object.h>

#include <ags/libags.h>
#include <ags/libags-audio.h>

AgsAudio* setup_master(AgsApplicationContext *application_context);
AgsAudio* setup_slave(AgsApplicationContext *application_context);

AgsAudio*
setup_master(AgsApplicationContext *application_context)
{
  AgsAudio *audio;
  AgsChannel *channel;
  AgsRecallContainer *playback_play_container;
  AgsRecallContainer *playback_recall_container;
  
  GObject *soundcard;

  GList *list;
  GList *start_recall, *recall;

  guint n_audio_channels, n_output_pads, n_input_pads;
  gint position;
  
  /* get soundcard */
  list = ags_sound_provider_get_soundcard(AGS_SOUND_PROVIDER(application_context));
  soundcard = list->data;

  /* create master playback */
  audio = ags_audio_new(soundcard);

  n_audio_channels = 2;

  n_output_pads = 1;
  n_input_pads = 1;
  
  ags_audio_set_audio_channels(audio,
                               n_audio_channels);
  
  ags_audio_set_pads(audio,
                     AGS_TYPE_OUTPUT,
                     n_output_pads);
  ags_audio_set_pads(audio,
                     AGS_TYPE_INPUT,
                     n_input_pads);

  /* create recall container */
  position = 0;
  
  playback_play_container = ags_recall_container_new();
  playback_recall_container = ags_recall_container_new();
  
  start_recall = ags_fx_factory_create(audio,
				       playback_play_container, playback_recall_container,
				       "ags-fx-playback",
				       NULL,
				       NULL,
				       0, n_audio_channels,
				       0, n_output_pads,
				       position,
				       (AGS_FX_FACTORY_ADD |
					AGS_FX_FACTORY_INPUT),
				       0);

  g_list_free_full(start_recall,
		   (GDestroyNotify) g_object_unref);
  
  /* set output soundcard channel on ags-fx-playback */
  channel = audio->output;
  
  while(channel != NULL){
    recall = channel->play;

    while((recall = ags_recall_template_find_type(recall,
                                                  AGS_TYPE_FX_PLAYBACK_CHANNEL)) != NULL){
      g_object_set(recall->data,
		   "output-soundcard-channel", channel->audio_channel,
		   NULL);

      recall = recall->next;
    }

    channel = channel->next;
  }

  return(audio);
}

AgsAudio*
setup_slave(AgsApplicationContext *application_context)
{
  AgsAudio *audio;
  AgsChannel *channel;
  AgsAudioSignal *audio_signal;
  AgsPattern *pattern;
  AgsRecallContainer *pattern_play_container;
  AgsRecallContainer *pattern_recall_container;  
  AgsRecallContainer *buffer_play_container;
  AgsRecallContainer *buffer_recall_container;

  AgsDelayAudioRun *play_delay_audio_run;
  AgsCountBeatsAudioRun *play_count_beats_audio_run;

  GObject *soundcard;

  GList *list;
  GList *start_recall, *recall;

  guint n_audio_channels, n_output_pads, n_input_pads;
  gint position;
  gdouble volume;
  guint current_phase, prev_phase;
  guint i, j, k;
  
  GValue value;
  
  /* get soundcard */
  list = ags_sound_provider_get_soundcard(AGS_SOUND_PROVIDER(application_context));
  soundcard = list->data;

  /* create master playback */
  audio = ags_audio_new(soundcard);
  ags_audio_set_flags(audio,
		      (AGS_AUDIO_OUTPUT_HAS_RECYCLING |
		       AGS_AUDIO_INPUT_HAS_RECYCLING));
  ags_audio_set_ability_flags(audio, (AGS_SOUND_ABILITY_SEQUENCER));
  ags_audio_set_behaviour_flags(audio, (AGS_SOUND_BEHAVIOUR_PATTERN_MODE |
					AGS_SOUND_BEHAVIOUR_REVERSE_MAPPING |
					AGS_SOUND_BEHAVIOUR_DEFAULTS_TO_INPUT));

  n_audio_channels = 2;

  n_output_pads = 1;
  n_input_pads = 1;
  
  ags_audio_set_audio_channels(audio,
                               n_audio_channels);
  
  ags_audio_set_pads(audio,
                     AGS_TYPE_OUTPUT,
                     n_output_pads);
  ags_audio_set_pads(audio,
                     AGS_TYPE_INPUT,
                     n_input_pads);

  /* add pattern and generate sound */
  channel = audio->output;

  while(channel != NULL){
    ags_channel_set_ability_flags(channel, (AGS_SOUND_ABILITY_SEQUENCER));

    channel = channel->next;
  }
  
  /* add pattern and generate sound */
  channel = audio->input;
  
  for(i = 0; i < n_input_pads; i++){
    for(j = 0; j < n_audio_channels; j++){
      /* pattern */
      pattern = channel->pattern->data;

      for(k = 0; k < 16;){
        ags_pattern_toggle_bit(pattern,
                               0,
                               0,
                               k);
        
        k += 4;
      }

      /* sound */
      audio_signal = ags_audio_signal_new();
      ags_audio_signal_set_flags(audio_signal,
				 AGS_AUDIO_SIGNAL_TEMPLATE);
      ags_audio_signal_stream_resize(audio_signal,
                                     5);
      
      stream = audio_signal->stream;

      current_phase = 0;
      volume = 1.0;

      k = 0;
      
      while(stream != NULL){
        ags_synth_sin(soundcard, (signed short *) stream->data,
                      0, 440.0, current_phase, audio_signal->buffer_size,
                      volume);

        prev_phase = current_phase;
        current_phase = (prev_phase + (audio_signal->buffer_size) + k * audio_signal->buffer_size) % 440.0;

        stream = stream->next;
        k++;
      }

      ags_recycling_add_audio_signal(channel->first_recycling,
				     audio_signal);
      
      channel = channel->next;
    }
  }
  
  /* create recall container */
  position = 0;

  pattern_play_container = ags_recall_container_new();
  pattern_recall_container = ags_recall_container_new();

  buffer_play_container = ags_recall_container_new();
  buffer_recall_container = ags_recall_container_new();

  /* ags-fx-pattern */
  start_recall = ags_fx_factory_create(audio,
				       pattern_play_container, pattern_recall_container,
				       "ags-fx-pattern",
				       NULL,
				       NULL,
				       0, n_audio_channels,
				       0, n_input_pads,
				       position,
				       (AGS_FX_FACTORY_ADD | AGS_FX_FACTORY_INPUT),
				       0);

  g_list_free_full(start_recall,
		   (GDestroyNotify) g_object_unref);

  /* ags-fx-buffer */
  start_recall = ags_fx_factory_create(audio,
				       buffer_play_container, buffer_recall_container,
				       "ags-fx-buffer",
				       NULL,
				       NULL,
				       0, n_audio_channels,
				       0, n_input_pads,
				       position,
				       (AGS_FX_FACTORY_ADD | AGS_FX_FACTORY_INPUT),
				       0);

  g_list_free_full(start_recall,
		   (GDestroyNotify) g_object_unref);

  return(audio);
}

int
main(int argc, char **argv)
{
  AgsAudio *master, *slave;
  AgsChannel *output, *input;

  AgsStartAudio *start_audio;
  
  AgsThread *main_loop;
  AgsTaskLauncher *task_launcher;
  
  AgsApplicationContext *application_context;
  AgsConfig *config;

  GError *error;

  /* create application context */
  application_context = ags_audio_application_context_new();
  g_object_ref(audio_application_context);

  ags_application_context_prepare(audio_application_context);
  ags_application_context_setup(audio_application_context);

  task_launcher = ags_concurrency_provider_get_task_launcher(AGS_CONCURRENCY_PROVIDER(application_context));
  
  /* set config */
  config = application_context->config;

  ags_config_set_value(config,
                       AGS_CONFIG_THREAD,
                       "model",
                       "super-threaded");
  ags_config_set_value(config,
                       AGS_CONFIG_THREAD,
                       "super-threaded-scope",
                       "channel");

  /* main loop */
  main_loop = application_context->main_loop;

  /* setup audio tree */
  master = setup_master(application_context);
  slave = setup_slave(application_context);

  /* set link */
  input = master->input;
  output = slave->output;

  while(input != NULL &&
        output != NULL){
    error = NULL;
    ags_channel_set_link(input,
                         output,
                         &error);

    if(error != NULL){
      g_message("%s", error->message);
    }
    
    input = input->next;
    output = output->next;
  }

  start_audio = ags_start_audio_new(slave,
				    AGS_SOUND_SCOPE_SEQUENCER);

  /* launch task */
  sleep(3);

  ags_task_launcher_add_task(task_launcher,
			     start_audio);

  /* GLib's main loop */
  g_main_loop_run(g_main_loop_new(NULL,
				  FALSE));
  
  return(0);
}
